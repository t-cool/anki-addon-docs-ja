<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Anki のアドオンを書く</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> はじめに</a></li><li class="chapter-item expanded "><a href="support.html"><strong aria-hidden="true">2.</strong> サポート</a></li><li class="chapter-item expanded "><a href="editor-setup.html"><strong aria-hidden="true">3.</strong> エディターの設定</a></li><li class="chapter-item expanded "><a href="mypy.html"><strong aria-hidden="true">4.</strong> MyPy</a></li><li class="chapter-item expanded "><a href="addon-folders.html"><strong aria-hidden="true">5.</strong> アドオンのフォルダー</a></li><li class="chapter-item expanded "><a href="a-basic-addon.html"><strong aria-hidden="true">6.</strong> 基本的なアドオン</a></li><li class="chapter-item expanded "><a href="the-anki-module.html"><strong aria-hidden="true">7.</strong> anki のモジュール</a></li><li class="chapter-item expanded "><a href="command-line-use.html"><strong aria-hidden="true">8.</strong> コマンドラインの使用</a></li><li class="chapter-item expanded "><a href="hooks-and-filters.html"><strong aria-hidden="true">9.</strong> フックとフィルター</a></li><li class="chapter-item expanded "><a href="background-ops.html"><strong aria-hidden="true">10.</strong> バックグラウンドの操作</a></li><li class="chapter-item expanded "><a href="qt.html"><strong aria-hidden="true">11.</strong> Qt と PyQt</a></li><li class="chapter-item expanded "><a href="python-modules.html"><strong aria-hidden="true">12.</strong> Python のモジュール</a></li><li class="chapter-item expanded "><a href="addon-config.html"><strong aria-hidden="true">13.</strong> アドオンの設定</a></li><li class="chapter-item expanded "><a href="reviewer-javascript.html"><strong aria-hidden="true">14.</strong> レビュアーの Javascript</a></li><li class="chapter-item expanded "><a href="debugging.html"><strong aria-hidden="true">15.</strong> デバッグ</a></li><li class="chapter-item expanded "><a href="monkey-patching.html"><strong aria-hidden="true">16.</strong> モンキーパッチ</a></li><li class="chapter-item expanded "><a href="sharing.html"><strong aria-hidden="true">17.</strong> アドオンの共有</a></li><li class="chapter-item expanded "><a href="porting2.0.html"><strong aria-hidden="true">18.</strong> 2.0 版アドオンの移植</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Anki のアドオンを書く</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/t-cool/anki-addon-docs-ja" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="はじめに"><a class="header" href="#はじめに">はじめに</a></h1>
<h2 id="概要"><a class="header" href="#概要">概要</a></h2>
<p>Anki の UI は、主に Python/PyQt で記述されています。レビューや編集用の画面など、多くの画面は Python/PyQt で書かれています。
画面やエディターには、TypeScript や Svelte も使われています。アドオンを書くには基本的なプログラミングの経験と、Pythonに精通していることが必要です。<a href="http://docs.python.org/tutorial/">Python
チュートリアル</a> が参考になります。</p>
<p>Anki のアドオンは Python モジュールとして実装され、Anki は起動時にこれを読み込みます。
アドオンは、特定のアクションが発生したときに通知されるように登録することができます。例えば、ブラウズ画面がロードされたときに実行されるフックを登録したり、特定アクションが実行された際に UI に変化を加えることができます（例: 新しいメニューの UI を追加等）。</p>
<p>Anki のアーキテクチャの概要は<a href="https://github.com/ankitects/anki/blob/main/docs/architecture.md">こちら</a> を参照してください。</p>
<p>普通のテキストエディタで Anki のアドオンを開発することも可能ですが、コードエディターや IDE を使えば、開発がより楽になります。 詳しくは下記の「IDE と 型ヒント」のセクションをご覧ください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="サポート"><a class="header" href="#サポート">サポート</a></h1>
<p>この文書には、始めるためのヒントがいくつか含まれていますが、包括的なガイドではありません。実際にアドオンを作成するには、Anki のソースコードや、以下のソースコードに精通する必要があります。
あなたが達成しようとしていることと似たようなことを行う他のアドオンです。</p>
<p>私たちのリソースには限りがあるため、<strong>アドオンの作成に関する公式なサポートはありません</strong>。質問がある場合は、ソースコードから自分で答えを見つけるか、<a href="https://forums.ankiweb.net/c/development/12">開発フォーラム</a> に質問を投稿する必要があります。</p>
<p>また、アドオンフォーラムを利用して、誰かにアドオンの作成を依頼することもできます。誰かがあなたの手助けをすることに興味を持つ前に、いくらか開発費を提供する必要があるかもしれません。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="エディターの設定"><a class="header" href="#エディターの設定">エディターの設定</a></h1>
<p>メモ帳などの基本的なテキストエディタでアドオンを書くこともできますが、適切な Python エディタ/開発環境（IDE）をセットアップすることで、かなり楽になります。</p>
<h2 id="pycharm-のセットアップ"><a class="header" href="#pycharm-のセットアップ">PyCharm のセットアップ</a></h2>
<p>PyCharm の無償コミュニティ版では、Python のサポートが充実しています: <a href="https://www.jetbrains.com/Pycharm/">https://www.jetbrains.com/Pycharm/</a>。Visual Studio Code のような他のエディタも使えますが、PyCharm が最も良い結果を出すことが分かっています。</p>
<p>昨年、Anki のコードベースは更新され、ほぼすべてのコードにタイプヒントが追加されました。これらの型ヒントは、より良いコード補完を提供し、mypy などのツールを使用してエラーを検出することで、開発を容易にします。アドオン作者として、あなたもこのタイプヒントを活用することができます。</p>
<p>最初のアドオンを始めるには、以下の流れで進めます：</p>
<ul>
<li>
<p>PyCharm を起動し、新規プロジェクトを作成します。</p>
</li>
<li>
<p>左側のプロジェクトを右クリック/ctrl+クリックし、&quot;myaddon &quot; という Python パッケージを新規に作成します。</p>
</li>
</ul>
<p>ここで、Anki にバンドルされているソースコードを取得し、型式補完ができるようにする必要があります。Anki 2.1.24 は現在、PyPI で入手可能です。<strong>Python の 64 ビット版を使用する必要があり、Python のバージョンは取得する Anki のバージョンがサポートするバージョンと一致する必要があります。</strong> Anki を PyCharm 経由でインストールするには、左下の Python Console をクリックし、次のように入力します。</p>
<pre><code class="language-python">import subprocess

subprocess.check_call([&quot;pip3&quot;, &quot;install&quot;, &quot;--upgrade&quot;, &quot;pip&quot;])
subprocess.check_call([&quot;pip3&quot;, &quot;install&quot;, &quot;mypy&quot;, &quot;aqt&quot;])
</code></pre>
<p>エンターキーを押して待ちます。完了したら、コード補完ができるはずです。</p>
<p>エラーが出る場合は、Pythonの64ビット版を使用していないか、Python のバージョンがAnki の最新版でサポートされていない可能性があります。上記のコマンドを「-vvv」付きで実行すると、より詳細な情報が得られます。</p>
<p>インストール後、<code>__init__.py</code> ファイルをダブルクリックして、コード補完を試してみてください。下の方にスピナーが表示されたら、完了するまで待ちます。その後、入力します。</p>
<pre><code class="language-python">from anki import hooks
hooks.
</code></pre>
<p>すると、補完がポップアップ表示されるはずです。</p>
<p><strong>PyCharm 内からアドオンを実行することはできませんのでご注意ください。エラーが発生します。</strong></p>
<p>アドオンは Anki 内から実行する必要があります。これは <a href="a-basic-addon.html">基本的なアドオン</a> のセクションで説明します。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mypy"><a class="header" href="#mypy">MyPy</a></h1>
<h2 id="mypy-の利用"><a class="header" href="#mypy-の利用">MyPy の利用</a></h2>
<p><a href="./editor-setup.html">PyCharmのセットアップ</a> の際にインストールした型ヒントは、MyPy というツールを使って、コードが正しいかどうかを確認することもできます。MyPy は、Anki の関数を誤って呼び出した場合、例えば関数名を間違って入力した場合や、整数を想定していたのに文字列を渡してしまった場合などに、その誤りを発見してくれます。</p>
<p>PyCharm で左下の Terminal をクリックし、'mypy myaddon' と入力してください。いくつかの処理の後、成功が表示されるか、またはあなたが犯したミスを教えてくれます。例えば、フックを間違って指定した場合を見てみましょう。</p>
<pre><code class="language-python">from aqt import gui_hooks

def myfunc() -&gt; None:
  print(&quot;myfunc&quot;)

gui_hooks.reviewer_did_show_answer.append(myfunc)
</code></pre>
<p>すると mypy は次のように報告します:</p>
<pre><code>myaddon/__init__.py:5: error: Argument 1 to &quot;append&quot; of &quot;list&quot; has incompatible type &quot;Callable[[], Any]&quot;; expected &quot;Callable[[Card], None]&quot;
Found 1 error in 1 file (checked 1 source file)
</code></pre>
<p>これは、フックが最初の引数としてカードを受け取る関数を期待していることを伝えています。</p>
<pre><code class="language-python">from anki.cards import Card

def myfunc(card: Card) -&gt; None:
  print(&quot;myfunc&quot;)
</code></pre>
<h2 id="既存のアドオンの確認"><a class="header" href="#既存のアドオンの確認">既存のアドオンの確認</a></h2>
<p>Mypy には &quot;check_untyped_defs&quot; オプションがあり、自分のコードに型ヒントがない場合でもある程度の型チェックを行うことができますが、これを最大限に活用するには、自分のコードに型ヒントを追加する必要があります。これは初期に時間がかかるかもしれませんが、長期的に見ると、自分のコードをナビゲートするのが容易になり、自分では定期的に実行しないようなコードの部分のエラーをキャッチすることができるようになるため有益です。また、新しい Anki バージョンに更新したときに発生した問題を簡単にチェックすることもできます。</p>
<p>既存の大規模なアドオンがある場合は、コードに自動的に型を追加する monkeytype のようなツールを検討するのもよいでしょう。</p>
<details>
<summary>Monkeytype</summary>
monkeytypeを test というアドオンで使うには、次のような方法があります。
<pre><code class="language-shell">% /usr/local/bin/python3.8 -m venv pyenv
% cd pyenv &amp;&amp; . bin/activate
(pyenv) % pip install aqt monkeytype
(pyenv) % monkeytype run bin/anki
</code></pre>
<p>その後、アドオン内をクリックしてランタイムタイプの情報を収集し、終了したら Anki を閉じます。</p>
<p>この後、トップレベルのアクション（関数外のメニューを変更するコードなど）は monkeytype がトリップしてしまうので、コメントアウトする必要があります。最後に、修正したファイルを次のように生成します:</p>
<pre><code class="language-shell">(pyenv) % PYTHONPATH=~/Library/Application\ Support/Anki2/addons21 monkeytype apply test
</code></pre>
</details>
<p>以下は、タイプヒントを使用するアドオンの例です:</p>
<p><a href="https://github.com/ankitects/anki-addons/blob/master/demos/">https://github.com/ankitects/anki-addons/blob/master/demos/</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="アドオンフォルダ"><a class="header" href="#アドオンフォルダ">アドオンフォルダ</a></h1>
<p>トップレベルのアドオンフォルダには、Tools からアクセスできます。
Add-ons メニュー項目を選択します。[ファイルを見る］ボタンをクリックすると、フォルダがポップアップ表示されます。アドオンがインストールされていない場合、トップレベルのアドオンフォルダが表示されます。アドオンを選択していた場合は、アドオンのモジュールフォルダが表示されますので、1つ上の階層に移動する必要があります。</p>
<p>アドオンフォルダは、Anki 2.1 に対応する addons21 という名前になっています。addons フォルダがある場合は、以前に Anki  2.0.x を使用したことがあるためです。</p>
<p>各アドオンは、アドオンフォルダ内の1つのフォルダを使用します。Anki は、そのフォルダの中にある <code>__init__.py</code> というファイルを探します。</p>
<pre><code>addons21/myaddon/__init__.py
</code></pre>
<p>もし <code>__init__.py</code> が存在しない場合、Anki はそのフォルダを無視します。</p>
<p>フォルダ名を決める際には、Pythonのモジュールシステムとの問題を避けるため、a-z と 0-9 の文字にこだわることをお勧めします。</p>
<p>自分で作成したフォルダには好きなフォルダ名を使用できますが、AnkiWeb からアドオンをダウンロードした場合、Anki はアイテムの ID をフォルダ名として使用し、次のようになります:</p>
<pre><code>addons21/48927303923/__init__.py
</code></pre>
<p>また、Anki はフォルダ内に meta.json ファイルを配置し、オリジナルのアドオン名、ダウンロードされた時期が有効かどうかを記録しています。</p>
<p>ユーザーデータは <a href="addon-config.html#config-json">ユーザーがアドオンをアップグレードすると削除される</a>ので、アドオンフォルダには保存しない方がよいでしょう。</p>
<p><a href="editor-setup.html">エディタの設定</a>セクションの手順に従った場合、myaddon フォルダを Anki のアドオンフォルダにコピーしてテストするか、Mac や Linux ではフォルダの元の場所からアドオンフォルダへシンボリックリンクを作成してください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-basic-add-on"><a class="header" href="#a-basic-add-on">A Basic Add-on</a></h1>
<p>アドオンフォルダ内の <code>my_first_addon/__init__.py</code> に以下を追加してください。</p>
<pre><code class="language-python"># aqt からメインウィンドウオブジェクト (mw) をインポートする
from aqt import mw
# utils.py から &quot;show info&quot; ツールをインポートする
from aqt.utils import showInfo, qconnect
# Qt GUI ライブラリをすべてインポートする
from aqt.qt import *

# 下にメニュー項目を追加していきます。まず、メニュー項目がアクティブになったときに呼び出される関数を作成したいと思います。

def testFunction() -&gt; None:
    # メインウィンドウに格納されている現在のコレクション内のカード枚数を取得します。
    cardCount = mw.col.cardCount()
    # メッセージボックスを表示する
    showInfo(&quot;Card count: %d&quot; % cardCount)

# 新しいメニュー項目 &quot;test &quot;を作成する
action = QAction(&quot;test&quot;, mw)
# クリックされたときに testFunction を呼び出すように設定する
qconnect(action.triggered, testFunction)
# そしてツールメニューに追加する
mw.form.menuTools.addAction(action)
</code></pre>
<p>Anki を再起動すると、ツールメニューに「テスト」項目が表示されるはずです。
これを実行すると、カード枚数を示すダイアログが表示されます。</p>
<p>プラグインの入力に間違いがあった場合、起動時にエラーメッセージが表示され、問題の場所が示されます。 </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anki-モジュール"><a class="header" href="#anki-モジュール">'anki' モジュール</a></h1>
<p>コレクションや関連メディアへのアクセスは、Anki のソースレポジトリの <code>pylib/anki</code> にある <code>anki</code> という Python モジュールを通して行われます。</p>
<h2 id="コレクション"><a class="header" href="#コレクション">コレクション</a></h2>
<p>コレクションファイルに対するすべての操作は <code>Collection</code> オブジェクトを介してアクセスされます。現在開いているコレクションは、グローバルな <code>mw.col</code> を介してアクセスできます。ここで <code>mw</code> は <code>main window</code> の略です。Anki の外部で <code>anki</code> モジュールを使用する場合は、独自のコレクションオブジェクトを作成する必要があります。</p>
<p>以下に、いくつかの基本的な例を示します。これらは <a href="./a-basic-addon.html">testFunction()</a> のような場所に記述する必要があることに注意してください。アドオンは Anki 起動時に、コレクションやプロファイルが読み込まれる前に初期化されるため、アドオンで直接実行することはできません。</p>
<p>また、コレクションに直接アクセスすると、操作が迅速に完了しない場合、UI が一時的にフリーズする可能性があることに注意してください。</p>
<p><strong>期限のカードを取得する:</strong></p>
<pre><code class="language-python">card = mw.col.sched.getCard()
if not card:
    # current deck is finished
</code></pre>
<p><strong>カードに答える:</strong></p>
<pre><code class="language-python">mw.col.sched.answerCard(card, ease)
</code></pre>
<p><strong>ノートを編集する（各フィールドの末尾に new を付ける）:</strong></p>
<pre><code class="language-python">note = card.note()
for (name, value) in note.items():
    note[name] = value + &quot; new&quot;
mw.col.update_note(note)
</code></pre>
<p><strong>タグ x を持つノートのカードの ID を取得する:</strong></p>
<pre><code class="language-python">ids = mw.col.find_cards(&quot;tag:x&quot;)
</code></pre>
<p><strong>それぞれの ID に対応する質問と回答を取得する:</strong></p>
<pre><code class="language-python">for id in ids:
    card = mw.col.get_card(id)
    question = card.question()
    answer = card.answer()
</code></pre>
<p><strong>レビューの期限を明日にする</strong></p>
<pre><code class="language-python">ids = mw.col.find_cards(&quot;is:due&quot;)
mw.col.sched.set_due_date(ids, &quot;1&quot;)
</code></pre>
<p><strong>テキストファイルをコレクションにインポートする</strong></p>
<p>このAPIは混乱していて、近々更新される予定です。</p>
<pre><code class="language-python">from anki.importing import TextImporter
file = u&quot;/path/to/text.txt&quot;
# デッキを選択する
deck_id = mw.col.decks.id(&quot;ImportDeck&quot;)
mw.col.decks.select(deck_id)
# ankiは選択されたデッキで最後に使用されたノートタイプをデフォルトとします
notetype = mw.col.models.by_name(&quot;Basic&quot;)
deck = mw.col.decks.get(deck_id)
deck['mid'] = notetype['id']
mw.col.decks.save(deck)
# ノートタイプで最後に使用したデッキにカードを入れる
mw.col.set_aux_notetype_config(
    notetype[&quot;id&quot;], &quot;lastDeck&quot;, deck_id
)
mw.col.models.save(m)
# コレクションに取り込む
ti = TextImporter(mw.col, file)
ti.initMapping()
ti.run()
</code></pre>
<p>ほぼすべてのGUI操作には Anki と関連する関数があり、Anki が利用可能な操作はすべてアドオンでも呼び出すことができます。</p>
<h2 id="オブジェクトの読み取り書き込み"><a class="header" href="#オブジェクトの読み取り書き込み">オブジェクトの読み取り/書き込み</a></h2>
<p>Anki のほとんどのオブジェクトは、pylib のメソッドで読み書きが可能です。</p>
<pre><code class="language-python">card = col.get_card(card_id)
card.ivl += 1
col.update_card(card)
</code></pre>
<pre><code class="language-python">note = col.get_note(note_id)
note[&quot;Front&quot;] += &quot; hello&quot;
col.update_note(note)
</code></pre>
<pre><code class="language-python">deck = col.decks.get(deck_id)
deck[&quot;name&quot;] += &quot; hello&quot;
col.decks.save(deck)

deck = col.decks.by_name(&quot;Default hello&quot;)
...
</code></pre>
<pre><code class="language-python">config = col.decks.get_config(config_id)
config[&quot;new&quot;][&quot;perDay&quot;] = 20
col.decks.save(config)
</code></pre>
<pre><code class="language-python">notetype = col.models.get(notetype_id)
notetype[&quot;css&quot;] += &quot;\nbody { background: grey; }\n&quot;
col.models.save(note)

notetype = col.models.by_name(&quot;Basic&quot;)
...
</code></pre>
<p>データベースに直接アクセスするよりも、これらのメソッドを使用した方が、同期が必要な項目をマークしたり、無効なデータがデータベースに書き込まれるのを防いだりすることができるからです。</p>
<p>特定のカードやノートを探すには、 col.find_cards() と col.find_notes() が便利です。</p>
<h2 id="データベース"><a class="header" href="#データベース">データベース</a></h2>
<p>:warning: データベースに直接書き込むと、簡単に問題を起こすことができます。可能な限り、代わりに上記のようなメソッドを使用してください。</p>
<p>Anki の DB オブジェクトは、以下の機能をサポートしています。</p>
<p><strong>scalar() は単一の項目を返します:</strong></p>
<pre><code class="language-python">showInfo(&quot;card count: %d&quot; % mw.col.db.scalar(&quot;select count() from cards&quot;))
</code></pre>
<p><strong>list() は、各行の最初の列のリストを返します:</strong></p>
<pre><code class="language-python">ids = mw.col.db.list(&quot;select id from cards limit 3&quot;)
</code></pre>
<p><strong>all() は、行のリストを返します:</strong></p>
<pre><code class="language-python">ids_and_ivl = mw.col.db.all(&quot;select id, ivl from cards&quot;)
</code></pre>
<p><strong>execute() は、中間リストを作成せずに結果セットを反復処理するために使用することもできます：</strong></p>
<pre><code class="language-python">for id, ivl in mw.col.db.execute(&quot;select id, ivl from cards limit 3&quot;):
    showInfo(&quot;card id %d has ivl %d&quot; % (id, ivl))
</code></pre>
<p><strong>execute() を使用すると、挿入や更新の操作を実行することができます。名前付き引数を使用するには ? を使います:</strong></p>
<pre><code class="language-python">mw.col.db.execute(&quot;update cards set ivl = ? where id = ?&quot;, newIvl, cardId)
</code></pre>
<p>なお、これらの変更は、前のセクションで説明した機能を使用した場合のように、同期されることはありません。</p>
<p><strong>executemany() を使用すると、更新や挿入の操作を一括して行うことができます。大きな更新を行う場合は、データポイントごとに execute() をコールするよりもずっと高速になります:</strong></p>
<pre><code class="language-python">data = [[newIvl1, cardId1], [newIvl2, cardId2]]
mw.col.db.executemany(same_sql_as_above, data)
</code></pre>
<p>上記のように、これらの変更は同期されません。</p>
<p>アドオンによって既存のテーブルのスキーマが変更されると、Anki の将来のバージョンで問題が発生する可能性があるため、絶対に変更しないでください。</p>
<p>アドオン固有のデータを保存する必要がある場合は、Anki の <a href="addon-config.html#config-json">Configuration</a> サポートの利用を検討してください。</p>
<p>デバイス間でデータを同期する必要がある場合、小さなオプションは mw.col.conf 内に保存することができます。現在、同期ごとに送信されるため、大量のデータをそこに保存しないようにしてください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-use"><a class="header" href="#command-line-use">Command-Line Use</a></h1>
<p>The <code>anki</code> module can be used separately from Anki's GUI. It is strongly recommended you use it instead of attempting to read or write a .anki2 file directly.</p>
<p>Install it with pip:</p>
<pre><code class="language-shell">$ pip install anki
</code></pre>
<p>Then you create use it in a .py file, like so:</p>
<pre><code class="language-python">from anki.collection import Collection
col = Collection(&quot;/path/to/collection.anki2&quot;)
print(col.sched.deck_due_tree())
col.close()
</code></pre>
<p>See <a href="./the-anki-module.html">the Anki module</a> for more.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hooks--filters"><a class="header" href="#hooks--filters">Hooks &amp; Filters</a></h1>
<ul>
<li><a href="hooks-and-filters.html#new-style-hooks">New Style Hooks</a></li>
<li><a href="hooks-and-filters.html#notable-hooks">Notable Hooks</a>
<ul>
<li><a href="hooks-and-filters.html#webview">Webview</a></li>
</ul>
</li>
<li><a href="hooks-and-filters.html#legacy-hook-handling">Legacy Hook Handling</a></li>
<li><a href="hooks-and-filters.html#adding-hooks">Adding Hooks</a></li>
</ul>
<p>Hooks are the way you should connect your add-on code to Anki. If the function you want to alter doesn’t already have a hook, please see the section below about adding new hooks.</p>
<p>There are two different kinds of &quot;hooks&quot;:</p>
<ul>
<li>
<p>Regular hooks are functions that don’t return anything. They are run for their side effects, and may sometimes alter the objects they have been passed, such as inserting an extra item in a list.</p>
</li>
<li>
<p>&quot;Filters&quot; are functions that return their first argument, after maybe changing it. An example filter is one that takes the text of a field during card display, and returns an altered version.</p>
</li>
</ul>
<p>The distinction is necessary because some data types in Python can be modified directly, and others can only be modified by creating a changed copy (such as strings).</p>
<h2 id="new-style-hooks"><a class="header" href="#new-style-hooks">New Style Hooks</a></h2>
<p>A new style of hook was added in Anki 2.1.20.</p>
<p>Imagine you wish to show a message each time the front side of a card is shown in the review screen. You’ve looked at the source code in reviewer.py, and seen the following line in the showQuestion() function:</p>
<pre><code class="language-python">gui_hooks.reviewer_did_show_question(card)
</code></pre>
<p>To register a function to be called when this hook is run, you can do the following in your add-on:</p>
<pre><code class="language-python">from aqt import gui_hooks

def myfunc(card):
  print(&quot;question shown, card question is:&quot;, card.q())

gui_hooks.reviewer_did_show_question.append(myfunc)
</code></pre>
<p>Multiple add-ons can register for the same hook or filter - they will all be called in turn.</p>
<p>To remove a hook, use code like:</p>
<pre><code>gui_hooks.reviewer_did_show_question.remove(myfunc)
</code></pre>
<p>:warning: Functions you attach to a hook should not modify the hook while they are executing, as it will break things:</p>
<pre><code>def myfunc(card):
  # DON'T DO THIS!
  gui_hooks.reviewer_did_show_question.remove(myfunc)

gui_hooks.reviewer_did_show_question.append(myfunc)
</code></pre>
<p>An easy way to see all hooks at a glance is to look at pylib/tools/genhooks.py and qt/tools/genhooks_gui.py.</p>
<p>If you have set up type completion as described in an earlier section, you can also see the hooks in your IDE:</p>
<video controls autoplay loop muted>
 <source src="../img/autocomplete.mp4" type="video/mp4">
</video>
<p>In the above video, holding the command/ctrl key down while hovering will show a tooltip, including arguments and documentation if it exists. The argument names and types for the callback can be seen on the bottom
line.</p>
<p>For some examples of how the new hooks are used, please see
<a href="https://github.com/ankitects/anki-addons/blob/master/demos/">https://github.com/ankitects/anki-addons/blob/master/demos/</a>.</p>
<p>Most of the new style hooks will also call the legacy hooks (described further below), so old add-ons will continue to work for now, but add-on authors are encouraged to update to the new style as it allows for code completion, and better error checking.</p>
<h2 id="notable-hooks"><a class="header" href="#notable-hooks">Notable Hooks</a></h2>
<p>For a full list of hooks, and their documentation, please see</p>
<ul>
<li><a href="https://github.com/ankitects/anki/blob/master/qt/tools/genhooks_gui.py">The GUI hooks</a></li>
<li><a href="https://github.com/ankitects/anki/blob/master/pylib/tools/genhooks.py">The pylib hooks</a></li>
</ul>
<h3 id="webview"><a class="header" href="#webview">Webview</a></h3>
<p>Many of Anki's screens are built with one or more webviews, and there are some hooks you can use to intercept their use.</p>
<p>From Anki 2.1.22:</p>
<ul>
<li><code>gui_hooks.webview_will_set_content()</code> allows you to modify the HTML that various screens send to the webview. You can use this for adding your own HTML/CSS/Javascript to particular screens. This will not work for external pages - see the Anki 2.1.36 section below.</li>
<li><code>gui_hooks.webview_did_receive_js_message()</code> allows you to intercept messages sent from Javascript. Anki provides a <code>pycmd(string)</code> function in Javascript which sends a message back to Python, and various screens such as reviewer.py respond to the messages. By using this hook, you can respond to your own messages as well.</li>
</ul>
<p>From Anki 2.1.36:</p>
<ul>
<li><code>webview_did_inject_style_into_page()</code> gives you an opportunity to inject styling or content into external pages like the graphs screen and congratulations page that are loaded with load_ts_page().</li>
</ul>
<h2 id="legacy-hook-handling"><a class="header" href="#legacy-hook-handling">Legacy Hook Handling</a></h2>
<p>Older versions of Anki used a different hook system, using the functions runHook(), addHook() and runFilter().</p>
<p>For example, when the scheduler (anki/sched.py) discovers a leech, it calls:</p>
<pre><code class="language-python">runHook(&quot;leech&quot;, card)
</code></pre>
<p>If you wished to perform a special operation when a leech was discovered, such as moving the card to a &quot;Difficult&quot; deck, you could do it with the following code:</p>
<pre><code class="language-python">from anki.hooks import addHook
from aqt import mw

def onLeech(card):
    # can modify without .flush(), as scheduler will do it for us
    card.did = mw.col.decks.id(&quot;Difficult&quot;)
    # if the card was in a cram deck, we have to put back the original due
    # time and original deck
    card.odid = 0
    if card.odue:
        card.due = card.odue
        card.odue = 0

addHook(&quot;leech&quot;, onLeech)
</code></pre>
<p>An example of a filter is in aqt/editor.py. The editor calls the &quot;editFocusLost&quot; filter each time a field loses focus, so that add-ons can apply changes to the note:</p>
<pre><code class="language-python">if runFilter(
    &quot;editFocusLost&quot;, False, self.note, self.currentField):
    # something updated the note; schedule reload
    def onUpdate():
        self.loadNote()
        self.checkValid()
    self.mw.progress.timer(100, onUpdate, False)
</code></pre>
<p>Each filter in this example accepts three arguments: a modified flag, the note, and the current field. If a filter makes no changes it returns the modified flag the same as it received it; if it makes a change it returns True. In this way, if any single add-on makes a change, the UI will reload the note to show updates.</p>
<p>The Japanese Support add-on uses this hook to automatically generate one field from another. A slightly simplified version is presented below:</p>
<pre><code class="language-python">def onFocusLost(flag, n, fidx):
    from aqt import mw
    # japanese model?
    if &quot;japanese&quot; not in n.model()['name'].lower():
        return flag
    # have src and dst fields?
    for c, name in enumerate(mw.col.models.fieldNames(n.model())):
        for f in srcFields:
            if name == f:
                src = f
                srcIdx = c
        for f in dstFields:
            if name == f:
                dst = f
    if not src or not dst:
        return flag
    # dst field already filled?
    if n[dst]:
        return flag
    # event coming from src field?
    if fidx != srcIdx:
        return flag
    # grab source text
    srcTxt = mw.col.media.strip(n[src])
    if not srcTxt:
        return flag
    # update field
    try:
        n[dst] = mecab.reading(srcTxt)
    except Exception, e:
        mecab = None
        raise
    return True

addHook('editFocusLost', onFocusLost)
</code></pre>
<p>The first argument of a filter is the argument that should be returned.
In the focus lost filter this is a flag, but in other cases it may be some other object. For example, in anki/collection.py, _renderQA() calls the &quot;mungeQA&quot; filter which contains the generated HTML for the front and back of cards. latex.py uses this filter to convert text in LaTeX tags into images.</p>
<p>In Anki 2.1, a hook was added for adding buttons to the editor. It can be used like so:</p>
<pre><code class="language-python">from aqt.utils import showInfo
from anki.hooks import addHook

# cross out the currently selected text
def onStrike(editor):
    editor.web.eval(&quot;wrap('&lt;del&gt;', '&lt;/del&gt;');&quot;)

def addMyButton(buttons, editor):
    editor._links['strike'] = onStrike
    return buttons + [editor._addButton(
        &quot;iconname&quot;, # &quot;/full/path/to/icon.png&quot;,
        &quot;strike&quot;, # link name
        &quot;tooltip&quot;)]

addHook(&quot;setupEditorButtons&quot;, addMyButton)
</code></pre>
<h2 id="adding-hooks"><a class="header" href="#adding-hooks">Adding Hooks</a></h2>
<p>If you want to modify a function that doesn’t already have a hook, please submit a pull request that adds the hooks you need.</p>
<p>The hook definitions are located in <code>pylib/tools/genhooks.py</code> and <code>qt/tools/genhooks_gui.py</code>. When building Anki, the build scripts will automatically update the hook files with the definitions listed there.</p>
<p>Please see the docs/ folder in the source tree for more information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="background-operations"><a class="header" href="#background-operations">Background Operations</a></h1>
<p>If your add-on performs a long-running operation directly, the user interface will freeze until the operation completes - no progress window will be shown, and the app will look as if it's stuck. This is annoying for users, so care should be taken to avoid it happening.</p>
<p>The reason it happens is because the user interface runs on the &quot;main thread&quot;. When your add-on performs a long-running operation directly, it also runs on the main thread, and it prevents the UI code from running again until your operation completes. The solution is to run your add-on code in a background thread, so that the UI can continue to function.</p>
<p>A complicating factor is that any code you write that interacts with the UI also needs to be run on the main thread. If your add-on only ran in the background, and it attempted to access the UI, it would cause Anki to crash. So selectivity is required - UI operations should be run on the main thread, and long-running operations like collection and network access should be run in the background. Anki provides some tools to make this easier.</p>
<h2 id="read-onlynon-undoable-operations"><a class="header" href="#read-onlynon-undoable-operations">Read-Only/Non-Undoable Operations</a></h2>
<p>For long-running operations like gathering a group of notes, or things like network access, <code>QueryOp</code> is recommended.</p>
<p>In the following example, my_ui_action() will return quickly, and the operation will continue to run in the background until it completes. If it finishes successfully, on_success will be called.</p>
<pre><code class="language-python">from anki.collection import Collection
from aqt.operations import QueryOp
from aqt.utils import showInfo
from aqt import mw

def my_background_op(col: Collection, note_ids: list[int]) -&gt; int:
    # some long-running op, eg
    for id in note_ids:
        note = col.get_note(note_id)
        # ...

    return 123

def on_success(count: int) -&gt; None:
    showInfo(f&quot;my_background_op() returned {count}&quot;)

def my_ui_action(note_ids: list[int]):
    op = QueryOp(
        # the active window (main window in this case)
        parent=mw,
        # the operation is passed the collection for convenience; you can
        # ignore it if you wish
        op=lambda col: my_background_operation(col, note_ids),
        # this function will be called if op completes successfully,
        # and it is given the return value of the op
        success=on_success,
    )

    # if with_progress() is not called, no progress window will be shown.
    # note: QueryOp.with_progress() was broken until Anki 2.1.50
    op.with_progress().run_in_background()
</code></pre>
<p><strong>Be careful not to directly call any Qt/UI routines inside the background operation!</strong></p>
<ul>
<li>If you need to modify the UI after an operation completes (eg show a tooltip), you should do it from the success function.</li>
<li>If the operation needs data from the UI (eg a combo box value), that data should be gathered
prior to executing the operation.</li>
<li>If you need to update the UI during the background operation (eg to update the text of the
progress window), your operation needs to perform that update on the main thread. For example,
in a loop:</li>
</ul>
<pre><code class="language-python">if time.time() - last_progress &gt;= 0.1:
    aqt.mw.taskman.run_on_main(
        lambda: aqt.mw.progress.update(
            label=f&quot;Remaining: {remaining}&quot;,
            value=total - remaining,
            max=total,
        )
    )
    last_progress = time.time()
</code></pre>
<h2 id="collection-operations"><a class="header" href="#collection-operations">Collection Operations</a></h2>
<p>A separate <code>CollectionOp</code> is provided for undoable operations that modify the collection. It functions similarly to QueryOp, but will also update the UI as changes are made (eg refresh the Browse screen if any notes are changed).</p>
<p>Many undoable ops already have a <code>CollectionOp</code> defined in aqt/operations/*.py. You can often use one of them directly rather than having to create your own. For example:</p>
<pre><code class="language-python">from aqt.operations.note import remove_notes

def my_ui_action(note_ids: list[int]) -&gt; None:
    remove_notes(parent=mw, note_ids=note_ids).run_in_background()
</code></pre>
<p>By default that routine will show a tooltip on success. You can call .success() or .failure() on it to provide an alternative routine.</p>
<p>For more information on undo handling, including combining multiple operations into a single undo step, please see <a href="https://forums.ankiweb.net/t/add-on-porting-notes-for-anki-2-1-45/11212#undoredo-4">this forum page</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="qt-and-pyqt"><a class="header" href="#qt-and-pyqt">Qt and PyQt</a></h1>
<p>As mentioned in the overview, Anki uses PyQt for a lot of its UI, and the Qt documentation and <a href="https://www.riverbankcomputing.com/static/Docs/PyQt6/sip-classes.html">PyQt documentation</a> are invaluable for learning how to display different GUI widgets.</p>
<h2 id="qt-versions"><a class="header" href="#qt-versions">Qt Versions</a></h2>
<p>From Anki 2.1.50, separate builds are provided for PyQt5 and PyQt6. Generally speaking, if you write code that works in Qt6, and make sure to import any Qt classes from aqt.qt instead of directly from PyQt6, your code should also work in Qt5.</p>
<h2 id="designer-files"><a class="header" href="#designer-files">Designer Files</a></h2>
<p>Parts of Anki's UI are defined in .ui files, located in <code>qt/aqt/forms</code>. Anki's build process converts them into .py files. If you wish to build your add-on's UI in a similar way, you will need to install Python, and install a program called Qt Designer (Designer.app on macOS). On Linux, it may be available in your distro's packages; on Windows and Mac, you'll need to install it as part of a <a href="https://download.qt.io/">Qt install</a>. Once installed, you will need to use a program provided in the pyqt6 pip package to compile the .ui files.</p>
<p>Generated Python files for PyQt6 won't work with PyQt5 and vice versa, so if you wish to support both versions, you will need to build the .ui files twice, once with pyuic5, and once with pyuic6.</p>
<h2 id="garbage-collection"><a class="header" href="#garbage-collection">Garbage Collection</a></h2>
<p>One particular thing to bear in mind is that objects are garbage collected in Python, so if you do something like:</p>
<pre><code class="language-python">def myfunc():
    widget = QWidget()
    widget.show()
</code></pre>
<p>…​then the widget will disappear as soon as the function exits. To prevent this, assign top level widgets to an existing object, like:</p>
<pre><code class="language-python">def myfunc():
    mw.myWidget = widget = QWidget()
    widget.show()
</code></pre>
<p>This is often not required when you create a Qt object and give it an existing object as the parent, as the parent will keep a reference to the object.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-modules"><a class="header" href="#python-modules">Python Modules</a></h1>
<p>From Anki 2.1.50, the packaged builds include most built-in Python modules. Earlier versions ship with only the standard modules necessary to run Anki.</p>
<p>If your add-on uses a standard Python module that has not been included, or a package from PyPI, then your add-on will need to bundle the module.</p>
<p>For pure Python modules, this is usually as simple as putting them in a subfolder, and adjusting sys.path. For modules that that require C extensions such as numpy, things get a fair bit more complicated, as you'll need to bundle the different module versions for each platform, and ensure you're bundling a version that is compatible with the version of Python Anki is packaged with.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="add-on-config"><a class="header" href="#add-on-config">Add-on Config</a></h1>
<h2 id="config-json"><a class="header" href="#config-json">Config JSON</a></h2>
<p>If you include a config.json file with a JSON dictionary in it, Anki will allow users to edit it from the add-on manager.</p>
<p>A simple example: in config.json:</p>
<pre><code>{&quot;myvar&quot;: 5}
</code></pre>
<p>In config.md:</p>
<pre><code>This is documentation for this add-on's configuration, in *markdown* format.
</code></pre>
<p>In your add-on’s code:</p>
<pre><code class="language-python">from aqt import mw
config = mw.addonManager.getConfig(__name__)
print(&quot;var is&quot;, config['myvar'])
</code></pre>
<p>When updating your add-on, you can make changes to config.json. 
Any newly added keys will be merged with the existing configuration.</p>
<p>If you change the value of existing keys in config.json, users who have customized their configuration will continue to see the old values unless they use the &quot;restore defaults&quot; button.</p>
<p>If you need to programmatically modify the config, you can save your changes with:</p>
<pre><code class="language-python">mw.addonManager.writeConfig(__name__, config)
</code></pre>
<p>If no config.json file exists, getConfig() will return None - even if you have called writeConfig().</p>
<p>Add-ons that manage options in their own GUI can have that GUI displayed when the config button is clicked:</p>
<pre><code class="language-python">mw.addonManager.setConfigAction(__name__, myOptionsFunc)
</code></pre>
<p>Avoid key names starting with an underscore - they are reserved for future use by Anki.</p>
<h2 id="user-files"><a class="header" href="#user-files">User Files</a></h2>
<p>When your add-on needs configuration data other than simple keys and values, it can use a special folder called user_files in the root of your add-on’s folder. Any files placed in this folder will be preserved when the add-on is upgraded. All other files in the add-on folder are
removed on upgrade.</p>
<p>To ensure the user_files folder is created for the user, you can put a README.txt or similar file inside it before zipping up your add-on.</p>
<p>When Anki upgrades an add-on, it will ignore any files in the .zip that already exist in the user_files folder.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reviewer-javascript"><a class="header" href="#reviewer-javascript">Reviewer Javascript</a></h1>
<p>For a general solution not specific to card review, see <a href="hooks-and-filters.html#webview">the webview section</a>.</p>
<p>Anki provides a hook to modify the question and answer HTML before it is displayed in the review screen, preview dialog, and card layout screen. This can be useful for adding Javascript to the card.</p>
<p>An example:</p>
<pre><code class="language-python">from aqt import gui_hooks
def prepare(html, card, context):
    return html + &quot;&quot;&quot;
&lt;script&gt;
document.body.style.background = &quot;blue&quot;;
&lt;/script&gt;&quot;&quot;&quot;
gui_hooks.card_will_show.append(prepare)
</code></pre>
<p>The hook takes three arguments: the HTML of the question or answer, the current card object (so you can limit your add-on to specific note types for example), and a string representing the context the hook is running in.</p>
<p>Make sure you return the modified HTML.</p>
<p>Context is one of: &quot;reviewQuestion&quot;, &quot;reviewAnswer&quot;, &quot;clayoutQuestion&quot;, &quot;clayoutAnswer&quot;, &quot;previewQuestion&quot; or &quot;previewAnswer&quot;.</p>
<p>The answer preview in the card layout screen, and the previewer set to &quot;show both sides&quot; will only use the &quot;Answer&quot; context. This means Javascript you append on the back side of the card should not depend on Javascript that is only added on the front.</p>
<p>Because Anki fades the previous text out before revealing the new text, Javascript hooks are required to perform actions like scrolling at the correct time. You can use them like so:</p>
<pre><code class="language-python">from aqt import gui_hooks
def prepare(html, card, context):
    return html + &quot;&quot;&quot;
&lt;script&gt;
onUpdateHook.push(function () {
    window.scrollTo(0, 2000);
})
&lt;/script&gt;&quot;&quot;&quot;
gui_hooks.card_will_show.append(prepare)
</code></pre>
<ul>
<li>
<p>onUpdateHook fires after the new card has been placed in the DOM, but before it is shown.</p>
</li>
<li>
<p>onShownHook fires after the card has faded in.</p>
</li>
</ul>
<p>The hooks are reset each time the question or answer is shown.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<p>If your code throws an exception, it will be caught by Anki’s standard exception handler (which catches anything written to stderr). If you need to print information for debugging purposes, you can use aqt.utils.showInfo, or write it to stderr with sys.stderr.write(&quot;text\n&quot;).</p>
<h2 id="webviews"><a class="header" href="#webviews">Webviews</a></h2>
<p>If you set the env var QTWEBENGINE_REMOTE_DEBUGGING to 8080 prior to starting Anki, you can surf to http://localhost:8080 in Chrome to debug the visible webpages.</p>
<h2 id="debug-console"><a class="header" href="#debug-console">Debug Console</a></h2>
<p>Anki also includes a REPL. From within the program, press the <a href="https://docs.ankiweb.net/misc.html#debug-console">shortcut key</a> and a window will open up. You can enter expressions or statements into the top area, and then press ctrl+return/command+return to evaluate them. 
An example session follows:</p>
<pre><code>&gt;&gt;&gt; mw
&lt;no output&gt;

&gt;&gt;&gt; print(mw)
&lt;aqt.main.AnkiQt object at 0x10c0ddc20&gt;

&gt;&gt;&gt; invalidName
Traceback (most recent call last):
  File &quot;/Users/dae/Lib/anki/qt/aqt/main.py&quot;, line 933, in onDebugRet
    exec text
  File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;
NameError: name 'invalidName' is not defined

&gt;&gt;&gt; a = [a for a in dir(mw.form) if a.startswith(&quot;action&quot;)]
... print(a)
... print()
... pp(a)
['actionAbout', 'actionCheckMediaDatabase', ...]

['actionAbout',
 'actionCheckMediaDatabase',
 'actionDocumentation',
 'actionDonate',
 ...]

&gt;&gt;&gt; pp(mw.reviewer.card)
&lt;anki.cards.Card object at 0x112181150&gt;

&gt;&gt;&gt; pp(card()) # shortcut for mw.reviewer.card.__dict__
{'_note': &lt;anki.notes.Note object at 0x11221da90&gt;,
 '_qa': [...]
 'col': &lt;anki.collection._Collection object at 0x1122415d0&gt;,
 'data': u'',
 'did': 1,
 'due': -1,
 'factor': 2350,
 'flags': 0,
 'id': 1307820012852L,
 [...]
}

&gt;&gt;&gt; pp(bcard()) # shortcut for selected card in browser
&lt;as above&gt;
</code></pre>
<p>Note that you need to explicitly print an expression in order to see what it evaluates to. Anki exports pp() (pretty print) in the scope to make it easier to quickly dump the details of objects, and the shortcut ctrl+shift+return will wrap the current text in the upper area with pp() and execute the result.</p>
<h2 id="pdb"><a class="header" href="#pdb">PDB</a></h2>
<p>If you’re on Linux or are running Anki from source, it’s also possible to debug your script with pdb. Place the following line somewhere in your code, and when Anki reaches that point it will kick into the debugger in the terminal:</p>
<pre><code class="language-python">    from aqt.qt import debug; debug()
</code></pre>
<p>Alternatively you can export DEBUG=1 in your shell and it will kick into the debugger on an uncaught exception.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monkey-patching-and-method-wrapping"><a class="header" href="#monkey-patching-and-method-wrapping">Monkey Patching and Method Wrapping</a></h1>
<p>If you want to modify a function that doesn’t already have a hook, it’s possible to overwrite that function with a custom version instead. This is sometimes referred to as 'monkey patching'.</p>
<p>Monkey patching is useful in the testing stage, and while waiting for new hooks to be integrated into Anki. But please don’t rely on it long term, as monkey patching is very fragile, and will tend to break as Anki is updated in the future.</p>
<p>The only exception to the above is if you’re making extensive changes to Anki where adding new hooks would be impractical. In that case, you may unfortunately need to modify your add-on periodically as Anki is updated.</p>
<p>In aqt/editor.py there is a function setupButtons() which creates the buttons like bold, italics and so on that you see in the editor. Let’s imagine you want to add another button in your add-on.</p>
<p>Anki 2.1 no longer uses setupButtons(). The code below is still useful to understand how monkey patching works, but for adding buttons to the editor please see the setupEditorButtons hook described in the previous section.</p>
<p>The simplest way is to copy and paste the function from the Anki source code, add your text to the bottom, and then overwrite the original, like so:</p>
<pre><code class="language-python">from aqt.editor import Editor

def mySetupButtons(self):
    &lt;copy &amp; pasted code from original&gt;
    &lt;custom add-on code&gt;

Editor.setupButtons = mySetupButtons
</code></pre>
<p>This approach is fragile however, as if the original code is updated in a future version of Anki, you would also have to update your add-on. A better approach would be to save the original, and call it in our custom version:</p>
<pre><code class="language-python">from aqt.editor import Editor

def mySetupButtons(self):
    origSetupButtons(self)
    &lt;custom add-on code&gt;

origSetupButtons = Editor.setupButtons
Editor.setupButtons = mySetupButtons
</code></pre>
<p>Because this is a common operation, Anki provides a function called wrap() which makes this a little more convenient. A real example:</p>
<pre><code class="language-python">from anki.hooks import wrap
from aqt.editor import Editor
from aqt.utils import showInfo

def buttonPressed(self):
    showInfo(&quot;pressed &quot; + `self`)

def mySetupButtons(self):
    # - size=False tells Anki not to use a small button
    # - the lambda is necessary to pass the editor instance to the
    #   callback, as we're passing in a function rather than a bound
    #   method
    self._addButton(&quot;mybutton&quot;, lambda s=self: buttonPressed(self),
                    text=&quot;PressMe&quot;, size=False)

Editor.setupButtons = wrap(Editor.setupButtons, mySetupButtons)
</code></pre>
<p>By default, wrap() runs your custom code after the original code. You can pass a third argument, &quot;before&quot;, to reverse this. If you need to run code both before and after the original version, you can do so like so:</p>
<pre><code class="language-python">from anki.hooks import wrap
from aqt.editor import Editor

def mySetupButtons(self, _old):
    &lt;before code&gt;
    ret = _old(self)
    &lt;after code&gt;
    return ret

Editor.setupButtons = wrap(Editor.setupButtons, mySetupButtons, &quot;around&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sharing-add-ons"><a class="header" href="#sharing-add-ons">Sharing Add-ons</a></h1>
<ul>
<li><a href="sharing.html#sharing-via-ankiweb">Sharing via AnkiWeb</a></li>
<li><a href="sharing.html#sharing-outside-ankiweb">Sharing outside AnkiWeb</a></li>
</ul>
<h2 id="sharing-via-ankiweb"><a class="header" href="#sharing-via-ankiweb">Sharing via AnkiWeb</a></h2>
<p>You can package up an add-on for distribution by zipping it up, and giving it a name ending in .ankiaddon.</p>
<p>The top level folder should not be included in the zip file. For example, if you have a module like the following:</p>
<pre><code>addons21/myaddon/__init__.py
addons21/myaddon/my.data
</code></pre>
<p>Then the zip file contents should be:</p>
<pre><code>__init__.py
my.data
</code></pre>
<p>If you include the folder name in the zip like the following, AnkiWeb will not accept the zip file:</p>
<pre><code>myaddon/__init__.py
myaddon/my.data
</code></pre>
<p>On Unix-based machines, you can create a properly-formed file with the following command:</p>
<pre><code>$ cd myaddon &amp;&amp; zip -r ../myaddon.ankiaddon *
</code></pre>
<p>Python automatically creates <code>pycache</code> folders when your add-on is run. Please make sure you delete these prior to creating the zip file, as AnkiWeb can not accept zip files that contain <code>pycache</code> folders.</p>
<p>Once you’ve created a .ankiaddon file, you can use the Upload button on <a href="https://ankiweb.net/shared/addons/">https://ankiweb.net/shared/addons/</a> to share the add-on with others.</p>
<h2 id="sharing-outside-ankiweb"><a class="header" href="#sharing-outside-ankiweb">Sharing outside AnkiWeb</a></h2>
<p>If you wish to distribute .ankiaddon files outside of AnkiWeb, your add-on folder needs to contain a 'manifest.json' file. The file should contain at least two keys: 'package' specifies the folder name the add-on will be stored in, and 'name' specifies the name that will be shown to the user. You can optionally include a 'conflicts' key which is a list of other packages that conflict with the add-on, and a 'mod' key which specifies when the add-on was updated.</p>
<p>When Anki downloads add-ons from AnkiWeb, only the conflicts key is used from the manifest.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="porting-anki-20-add-ons"><a class="header" href="#porting-anki-20-add-ons">Porting Anki 2.0 add-ons</a></h1>
<ul>
<li><a href="porting2.0.html#python-3">Python 3</a></li>
<li><a href="porting2.0.html#qt5--pyqt5">Qt5 / PyQt5</a></li>
<li><a href="porting2.0.html#single-py-add-ons-need-their-own-folder">Single .py add-ons need their own folder</a></li>
<li><a href="porting2.0.html#folders-are-deleted-when-upgrading">Folders are deleted when upgrading</a></li>
<li><a href="porting2.0.html#supporting-both-20-and-21-in-one-codebase">Supporting both 2.0 and 2.1 in one codebase</a></li>
<li><a href="porting2.0.html#webview-changes">Webview Changes</a></li>
<li><a href="porting2.0.html#reviewer-changes">Reviewer Changes</a></li>
<li><a href="porting2.0.html#add-on-configuration">Add-on Configuration</a></li>
</ul>
<h2 id="python-3"><a class="header" href="#python-3">Python 3</a></h2>
<p>Anki 2.1 requires Python 3 or later. After installing Python 3 on your machine, you can use the 2to3 tool to automatically convert your existing scripts to Python 3 code on a folder by folder basis, like:</p>
<pre><code>2to3-3.8 --output-dir=aqt3 -W -n aqt
mv aqt aqt-old
mv aqt3 aqt
</code></pre>
<p>Most simple code can be converted automatically, but there may be parts of the code that you need to manually modify.</p>
<h2 id="qt5--pyqt5"><a class="header" href="#qt5--pyqt5">Qt5 / PyQt5</a></h2>
<p>The syntax for connecting signals and slots has changed in PyQt5. Recent PyQt4 versions support the new syntax as well, so the same syntax can be used for both Anki 2.0 and 2.1 add-ons.</p>
<p>More info is available at <a href="http://pyqt.sourceforge.net/Docs/PyQt4/new_style_signals_slots.html">http://pyqt.sourceforge.net/Docs/PyQt4/new_style_signals_slots.html</a></p>
<p>One add-on author reported that the following tool was useful to automatically convert the code:
<a href="https://github.com/rferrazz/pyqt4topyqt5">https://github.com/rferrazz/pyqt4topyqt5</a></p>
<p>The Qt modules are in 'PyQt5' instead of 'PyQt4'. You can do a conditional import, but an easier way is to import from aqt.qt - eg</p>
<pre><code>from aqt.qt import *
</code></pre>
<p>That will import all the Qt objects like QDialog without having to specify the Qt version.</p>
<h2 id="single-py-add-ons-need-their-own-folder"><a class="header" href="#single-py-add-ons-need-their-own-folder">Single .py add-ons need their own folder</a></h2>
<p>Each add-on is now stored in its own folder. If your add-on was previously called <code>demo.py</code>, you’ll need to create a <code>demo</code> folder with an <code>__init__.py</code> file.</p>
<p>If you don’t care about 2.0 compatibility, you can just rename <code>demo.py</code> to <code>demo/__init__.py</code>.</p>
<p>If you plan to support 2.0 with the same file, you can copy your original file into the folder (<code>demo.py</code> → <code>demo/demo.py</code>), and then import it relatively by adding the following to <code>demo/__init__.py</code>:</p>
<pre><code>from . import demo
</code></pre>
<p>The folder needs to be zipped up when uploading to AnkiWeb. For more info, please see <a href="sharing.html">sharing add-ons</a>.</p>
<h2 id="folders-are-deleted-when-upgrading"><a class="header" href="#folders-are-deleted-when-upgrading">Folders are deleted when upgrading</a></h2>
<p>When an add-on is upgraded, all files in the add-on folder are deleted. The only exception is the special <a href="addon-config.html#user-files">user_files folder</a>. If your add-on requires more than simple key/value configuration, make sure you store the associated files in the user_files folder, or they will be lost on upgrade.</p>
<h2 id="supporting-both-20-and-21-in-one-codebase"><a class="header" href="#supporting-both-20-and-21-in-one-codebase">Supporting both 2.0 and 2.1 in one codebase</a></h2>
<p>Most Python 3 code will run on Python 2 as well, so it is possible to update your add-ons in such a way that they run on both Anki 2.0 and 2.1. Whether this is worth it depends on the changes you need to make.</p>
<p>Most add-ons that affect the scheduler should require only minor changes to work on 2.1. Add-ons that alter the behaviour of the reviewer, browser or editor may require more work.</p>
<p>The most difficult part is the change from the unsupported QtWebKit to QtWebEngine. If you do any non-trivial work with webviews, some work will be required to port your code to Anki 2.1, and you may find it difficult to support both Anki versions in the one codebase.</p>
<p>If you find your add-on runs without modification, or requires only minor changes, you may find it easiest to add some if statements to your code and upload the same file for both 2.0.x and 2.1.x.</p>
<p>If your add-on requires more significant changes, you may find it easier to stop providing updates for 2.0.x, or to maintain separate files for the two Anki versions.</p>
<h2 id="webview-changes"><a class="header" href="#webview-changes">Webview Changes</a></h2>
<p>Qt 5 has dropped WebKit in favour of the Chromium-based WebEngine, so Anki’s webviews are now using WebEngine. Of note:</p>
<ul>
<li>
<p>You can now debug the webviews using an external Chrome instance, by setting the env var QTWEBENGINE_REMOTE_DEBUGGING to 8080 prior to starting Anki, then surfing to localhost:8080 in Chrome.</p>
</li>
<li>
<p>WebEngine uses a different method of communicating back to Python. AnkiWebView() is a wrapper for webviews which provides a pycmd(str) function in Javascript which will call the ankiwebview’s onBridgeCmd(str) method. Various parts of Anki’s UI like reviewer.py and deckbrowser.py have had to be modified to use this.</p>
</li>
<li>
<p>Javascript is evaluated asynchronously, so if you need the result of a JS expression you can use ankiwebview’s evalWithCallback().</p>
</li>
<li>
<p>As a result of this asynchronous behaviour, editor.saveNow() now requires a callback. If your add-on performs actions in the browser, you likely need to call editor.saveNow() first and then run the rest of your code in the callback. Calls to .onSearch() will need to be changed to .search()/.onSearchActivated() as well. See the browser’s .deleteNotes() for an example.</p>
</li>
<li>
<p>Various operations that were supported by WebKit like setScrollPosition() now need to be implemented in javascript.</p>
</li>
<li>
<p>Page actions like mw.web.triggerPageAction(QWebEnginePage.Copy) are also asynchronous, and need to be rewritten to use javascript or a delay.</p>
</li>
<li>
<p>WebEngine doesn’t provide a keyPressEvent() like WebKit did, so the code that catches shortcuts not attached to a menu or button has had to be changed. setStateShortcuts() fires a hook that can be used to adjust the shortcuts for a given state.</p>
</li>
</ul>
<h2 id="reviewer-changes"><a class="header" href="#reviewer-changes">Reviewer Changes</a></h2>
<p>Anki now fades the previous card out before fading the next card in, so the next card won’t be available in the DOM when the showQuestion hook fires. There are some new hooks you can use to run Javascript at the appropriate time - see <a href="reviewer-javascript.html">here</a> for more.</p>
<h2 id="add-on-configuration"><a class="header" href="#add-on-configuration">Add-on Configuration</a></h2>
<p>Many small 2.0 add-ons relied on users editing the sourcecode to customize them. This is no longer a good idea in 2.1, because changes made by the user will be overwritten when they check for and download updates. 2.1 provides a <a href="addon-config.html#config-json">Configuration</a> system to work around this. If you need to continue supporting 2.0 as well, you could use code like the following:</p>
<pre><code class="language-python">if getattr(getattr(mw, &quot;addonManager&quot;, None), &quot;getConfig&quot;, None):
    config = mw.addonManager.getConfig(__name__)
else:
    config = dict(optionA=123, optionB=456)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
